var fft_legacy=(function(b){"use strict";function ct(e,t){return[e[0]+t[0],e[1]+t[1]]}function _t(e,t){return[e[0]-t[0],e[1]-t[1]]}function lt(e,t){return[e[0]*t[0]-e[1]*t[1],e[0]*t[1]+e[1]*t[0]]}function dt(e){return Math.sqrt(e[0]**2+e[1]**2)}const $={};function O(e,t){const s=-2*Math.PI*(e/t);return $[t]??={},$[t][e]??=[Math.cos(s),Math.sin(s)],$[t][e]}function Tt(e){return e.map(dt).slice(0,e.length/2)}function Ft(e,t){const s=t/e.length;return e.slice(0,e.length/2).map((r,n)=>n*s)}const wt=Object.freeze(Object.defineProperty({__proto__:null,exponent:O,fftFreq:Ft,fftMag:Tt},Symbol.toStringTag,{value:"Module"}));function gt(e){if(e<1)return 1;let t=1;for(;t<e;)t<<=1;return t}class mt{size;vector;table;_csize;_width;_bitrev;_out=null;_data=null;_inv=0;data;freq=0;constructor(t){let s=t;t instanceof Float64Array||(s=Float64Array.from(t)),s.length<=2?this.size=gt(t.length):(this._csize=this.size<<1,this.size=s.length),this.data=new Float64Array(this._csize);for(let o=0;o<t.length;o++)this.data[o<<1]=t[o];this.table=new Float64Array(this._csize);for(let o=0;o<this._csize;o+=2){const i=Math.PI*(o>>1)/s.length;this.table[o]=Math.cos(i),this.table[o+1]=-Math.sin(i)}let r=0;for(let o=1;o<s.length;o<<=1)r++;this._width=r%2===0?r-1:r;const n=1<<this._width;this._bitrev=new Uint32Array(n);for(let o=0;o<n;o++){let i=0;for(let c=0;c<this._width;c+=2){const a=this._width-c-2;i|=(o>>>c&3)<<a}this._bitrev[o]=i}}setInverse(t){this._inv=t?1:0}fromComplexArray(t,s){const r=s||new Float64Array(t.length>>>1);for(let n=0;n<t.length;n+=2)r[n>>>1]=t[n];return r}createComplexArray(){return new Float64Array(this._csize)}bitReverse(t,s){let r=0;for(let n=0;n<s;n++)r=r<<1|t>>>n&1;return r}toComplexArray(t,s){const r=s||this.createComplexArray();for(let n=0;n<r.length;n+=2)r[n]=t[n>>>1]??0,r[n+1]=0;return r}completeSpectrum(t){const s=this._csize,r=s>>>1;for(let n=2;n<r;n+=2)t[s-n]=t[n],t[s-n+1]=-t[n+1];return t}transform(t,s){if(t===s)throw new Error("Input and output buffers must be different");this._out=t,this._data=s,this._inv=0,this._transform4(),this._out=null,this._data=null;const r=1/Math.sqrt(this.size);for(let n=0;n<t.length;n++)t[n]*=r}realTransform(t,s){if(t===s)throw new Error("Input and output buffers must be different");this._out=t,this._data=s instanceof Float64Array?s:Float64Array.from(s),this._inv=0,this._realTransform4(),this._out=null,this._data=null;const r=1/Math.sqrt(this.size);for(let n=0;n<t.length;n++)t[n]*=r}inverseTransform(t,s){if(t===s)throw new Error("Input and output buffers must be different");this._out=t,this._data=s,this._inv=1,this._transform4();const r=1/Math.sqrt(this.size);for(let n=0;n<t.length;n++)t[n]=this._out[n]*r;this._out=null,this._data=null}_transform4(){const t=this._out;if(!t)throw new Error("'out' buffer is null");const s=this._csize;let n=1<<this._width,o=s/n<<1,i,c;const a=this._bitrev;if(o===4)for(i=0,c=0;i<s;i+=o,c++){const h=a[c];this._singleTransform2(i,h,n)}else for(i=0,c=0;i<s;i+=o,c++){const h=a[c];this._singleTransform4(i,h,n)}const l=this._inv?-1:1;let u=this.table;for(n>>=2;n>=2;n>>=2){o=s/n<<1;const h=o>>>2;for(i=0;i<s;i+=o){const F=i+h;for(let g=i,f=0;g<F;g+=2,f+=n){const _=g,d=_+h,T=d+h,w=T+h,A=t[_],C=t[_+1],M=t[d],m=t[d+1],v=t[T],y=t[T+1],B=t[w],z=t[w+1],D=A,S=C,p=u[f],R=l*u[f+1],q=M*p-m*R,E=M*R+m*p,X=u[2*f],k=l*u[2*f+1],N=v*X-y*k,U=v*k+y*X,x=u[3*f],G=l*u[3*f+1],H=B*x-z*G,J=B*G+z*x,K=D+N,I=S+U,P=D-N,Q=S-U,V=q+H,L=E+J,j=l*(q-H),W=l*(E-J),Z=K+V,tt=I+L,nt=K-V,st=I-L,ot=P+W,rt=Q-j,et=P-W,it=Q+j;t[_]=Z,t[_+1]=tt,t[d]=ot,t[d+1]=rt,t[T]=nt,t[T+1]=st,t[w]=et,t[w+1]=it}}}}_singleTransform2(t,s,r){const n=this._out,o=this._data;if(!o||!n)throw new Error("'data' buffer is null");const i=o[s],c=o[s+1],a=o[s+r],l=o[s+r+1],u=i+a,h=c+l,F=i-a,g=c-l;n[t]=u,n[t+1]=h,n[t+2]=F,n[t+3]=g}_singleTransform4(t,s,r){const n=this._out,o=this._data;if(!o||!n)throw new Error("'data' buffer is null");const i=this._inv?-1:1,c=r*2,a=r*3,l=o[s],u=o[s+1],h=o[s+r],F=o[s+r+1],g=o[s+c],f=o[s+c+1],_=o[s+a],d=o[s+a+1],T=l+g,w=u+f,A=l-g,C=u-f,M=h+_,m=F+d,v=i*(h-_),y=i*(F-d),B=T+M,z=w+m,D=A+y,S=C-v,p=T-M,R=w-m,q=A-y,E=C+v;n[t]=B,n[t+1]=z,n[t+2]=D,n[t+3]=S,n[t+4]=p,n[t+5]=R,n[t+6]=q,n[t+7]=E}_realTransform4(){const t=this._out;if(!t)throw new Error("'data' buffer is null");const s=this._csize;let n=1<<this._width,o=s/n<<1,i,c;const a=this._bitrev;if(o===4)for(i=0,c=0;i<s;i+=o,c++){const h=a[c];this._singleRealTransform2(i,h>>>1,n>>>1)}else for(i=0,c=0;i<s;i+=o,c++){const h=a[c];this._singleRealTransform4(i,h>>>1,n>>>1)}const l=this._inv?-1:1,u=this.table;for(n>>=2;n>=2;n>>=2){o=s/n<<1;const h=o>>>1,F=h>>>1,g=F>>>1;for(i=0;i<s;i+=o)for(let f=0,_=0;f<=g;f+=2,_+=n){const d=i+f,T=d+F,w=T+F,A=w+F,C=t[d],M=t[d+1],m=t[T],v=t[T+1],y=t[w],B=t[w+1],z=t[A],D=t[A+1],S=C,p=M,R=u[_],q=l*u[_+1],E=m*R-v*q,X=m*q+v*R,k=u[2*_],N=l*u[2*_+1],U=y*k-B*N,x=y*N+B*k,G=u[3*_],H=l*u[3*_+1],J=z*G-D*H,K=z*H+D*G,I=S+U,P=p+x,Q=S-U,V=p-x,L=E+J,j=X+K,W=l*(E-J),Z=l*(X-K),tt=I+L,nt=P+j,st=Q+Z,ot=V-W;if(t[d]=tt,t[d+1]=nt,t[T]=st,t[T+1]=ot,f===0){const Et=I-L,It=P-j;t[w]=Et,t[w+1]=It;continue}if(f===g)continue;const rt=Q,et=-V,it=I,vt=-P,yt=-l*Z,Bt=-l*W,zt=-l*j,Dt=-l*L,St=rt+yt,pt=et+Bt,Rt=it+Dt,qt=vt-zt,ut=i+F-f,ft=i+h-f;t[ut]=St,t[ut+1]=pt,t[ft]=Rt,t[ft+1]=qt}}}_singleRealTransform2(t,s,r){const n=this._out,o=this._data;if(!o||!n)throw new Error("'data' buffer is null");const i=o[s],c=o[s+r],a=i+c,l=i-c;n[t]=a,n[t+1]=0,n[t+2]=l,n[t+3]=0}_singleRealTransform4(t,s,r){const n=this._out,o=this._data;if(!o||!n)throw new Error("'data' buffer is null");const i=this._inv?-1:1,c=r*2,a=r*3,l=o[s],u=o[s+r],h=o[s+c],F=o[s+a],g=l+h,f=l-h,_=u+F,d=i*(u-F),T=g+_,w=f,A=-d,C=g-_,M=f,m=d;n[t]=T,n[t+1]=0,n[t+2]=w,n[t+3]=A,n[t+4]=C,n[t+5]=0,n[t+6]=M,n[t+7]=m}}function Y(e){const t=e.length,s=[];if(t===1){const c=e[0];return[Array.isArray(c)?[c[0],c[1]]:[Number(c),0]]}const r=(c,a)=>a%2===0,n=(c,a)=>a%2===1,o=Y(e.filter(r)),i=Y(e.filter(n));for(let c=0;c<t/2;c++){const a=o[c],l=lt(O(c,t),i[c]);s[c]=ct(a,l),s[c+t/2]=_t(a,l)}return s}function bt(e){const t=new Float64Array(e.length);for(let s=0;s<e.length;s++){const[r,n]=e[s];t[s]=Math.hypot(r,n)}return t}function At(e){const t=e.length;if(t===0)return new Float64Array(0);if((t&t-1)===0)return e;let r=1;for(;r<t;)r<<=1;const n=new Float64Array(r);return n.set(e),n}function at(e){const t=At(e),s=Y(Array.from(t));return bt(s)}function Mt(e){const t=at(e),s=t.reduce((r,n)=>r+(Number.isFinite(n)?n:0),0);return s>0?t[0]/s:0}function ht(e){const t=e.length,s=[];for(let r=0;r<t;r++){let n=[0,0];for(let o=0;o<t;o++){const i=typeof e[o]=="number"?[e[o],0]:e[o],c=O(r*o,t);n=ct(n,lt(i,c))}s[r]=n}return s}function Ct(e){const t=e.map(([r,n])=>[n,r]),s=ht(t);return s.map(([r,n])=>[n/s.length,r/s.length])}return b.FFT=mt,b.deriveCoherence=Mt,b.dft=ht,b.fftFunc=Y,b.forwardMagnitudes=at,b.ifft=Ct,b.util=wt,Object.defineProperty(b,Symbol.toStringTag,{value:"Module"}),b})({});
