{"version":3,"file":"dft.js","sourceRoot":"","sources":["../src/dft.ts"],"names":[],"mappings":";AAAA,kFAAkF;AAClF,4DAA4D;AAC5D,KAAK;AACL,uDAAuD;AACvD,KAAK;AACL,4EAA4E;AAC5E,oDAAoD;AACpD,kFAAkF;AAClF,qCAAqC;AACrC,wCAAwC;AACxC,wCAAwC;AACxC,qDAAqD;AACrD,6CAA6C;AAC7C,sDAAsD;AACtD,WAAW;AACX,qDAAqD;;AAerD,kBAqBC;;AA5BD,2DAAqC;AACrC,2DAAqC;AAErC;;;GAGG;AACH,SAAgB,GAAG,CAAC,MAA4B;IAC9C,MAAM,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC;IACxB,MAAM,CAAC,GAAY,EAAE,CAAC;IAEtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3B,IAAI,GAAG,GAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC3B,MAAM,GAAG,GACP,OAAO,MAAM,CAAC,CAAC,CAAC,KAAK,QAAQ;gBAC3B,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAW,EAAE,CAAC,CAAC;gBAC1B,CAAC,CAAE,MAAM,CAAC,CAAC,CAAa,CAAC;YAE7B,MAAM,GAAG,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;YACvC,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;QACrD,CAAC;QAED,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;IACb,CAAC;IAED,OAAO,CAAC,CAAC;AACX,CAAC","sourcesContent":["// /*===========================================================================*\\\n//  * Discrete Fourier Transform (O(n^2) brute-force method)\n//  *\n//  * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n//  *\n//  * This code is not designed to be highly optimized but as an educational\n//  * tool to understand the Fast Fourier Transform.\n// \\*===========================================================================*/\n// import { Complex } from './types';\n// import * as complex from './complex';\n// import * as fftUtil from './fftutil';\n// //------------------------------------------------\n// // Note: this code is not optimized and is\n// // primarily designed as an educational and testing\n// // tool.\n// //------------------------------------------------\n\n// //-------------------------------------------------\n// // Calculate brute-force O(n^2) DFT for vector.\n// //-------------------------------------------------\n\n// dft.ts\nimport { Complex, Phasors } from './types/types';\nimport * as complex from './complex';\nimport * as fftUtil from './fftutil';\n\n/**\n * Brute-force O(n^2) Discrete Fourier Transform.\n * Converts a real or complex signal to the frequency domain.\n */\nexport function dft(vector: number[] | Complex[]): Phasors {\n  const N = vector.length;\n  const X: Phasors = [];\n\n  for (let k = 0; k < N; k++) {\n    let sum: Complex = [0, 0];\n\n    for (let i = 0; i < N; i++) {\n      const val: Complex =\n        typeof vector[i] === \"number\"\n          ? [vector[i] as number, 0]\n          : (vector[i] as Complex);\n\n      const exp = fftUtil.exponent(k * i, N);\n      sum = complex.add(sum, complex.multiply(val, exp));\n    }\n\n    X[k] = sum;\n  }\n\n  return X;\n}\n"]}